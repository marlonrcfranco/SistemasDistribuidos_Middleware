/** * MozartSpaces - Java implementation of Extensible Virtual Shared Memory (XVSM) * Copyright 2009-2012 Space Based Computing Group, eva Kuehn, E185/1, TU Vienna * Visit http://www.mozartspaces.org for more information. * * MozartSpaces is free software: you can redistribute it and/or * modify it under the terms of version 3 of the GNU Affero General * Public License as published by the Free Software Foundation. * * MozartSpaces is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Affero General Public License for more details. * * You should have received a copy of the GNU Affero General * Public License along with MozartSpaces. If not, see * <http://www.gnu.org/licenses/>. */options{  STATIC = false;
  IGNORE_CASE = true;}PARSER_BEGIN(CCOqlParser)package org.mozartspaces.util.parser.sql.javacc;import java.util.List;import java.util.ArrayList;import org.mozartspaces.util.parser.sql.SQLParserResult;import org.mozartspaces.util.parser.sql.ConditionType;import org.mozartspaces.capi3.ComparableProperty;import org.mozartspaces.capi3.Matchmaker;import org.mozartspaces.capi3.Matchmakers;
public class CCOqlParser {	public static String[] toPath(final String id) {		return id.split("\\.");	}		public static String likeToRegexPattern(final String likePattern) {		String pattern;		pattern = likePattern.replaceAll("%", ".*");		pattern = pattern.replaceAll("_", ".");		return pattern;	}		public static String unquoteString(final String input) {		String output;		if(input.startsWith("\'")) {			output = input.replaceAll("^\'", "");			output = output.replaceAll("\'$", "");		} else {			output = input.replaceAll("^\"", "");			output = output.replaceAll("\"$", "");		}		return output;	}		public static String stripSuffix(final String input) {		String output;		output = input.replaceAll("(l|L)$", "");		output = output.replaceAll("(f|F)$", "");		output = output.replaceAll("(d|D)$", "");		return output;	}}PARSER_END(CCOqlParser)SKIP :{	" "|	"\r"|	"\t"|	"\n"}TOKEN : /* SYMBOLS */{	< UNDERSCORE	: "_" >| 	< PERIOD		: "." >| 	< COMMA			: "," >| 	< OPEN_PARENS	: "(" >| 	< CLOSE_PARENS	: ")" >}TOKEN : /* NUMBERS */{	< INTEGER			: (<SIGN>)? (<DIGIT>)+ >|	< LONG				: (<SIGN>)? (<DIGIT>)+ <LONG_SUFFIX> >| 	< FLOAT				: (<SIGN>)? (<DIGIT>)* "." (<DIGIT>)+ <FLOAT_SUFFIX> >| 	< DOUBLE			: (<SIGN>)? (<DIGIT>)* "." (<DIGIT>)+ (<DOUBLE_SUFFIX>)? >|	< #DIGIT			: ["0"-"9"] >| 	< #SIGN				: ["+","-"] >| 	< #FLOAT_SUFFIX		: ["F","f"] >| 	< #DOUBLE_SUFFIX	: ["D","d"] >| 	< #LONG_SUFFIX		: ["L","l"] >}TOKEN : /* STRING */{	< STRING	: ( <SINGLE_QUOTED_STRING> | <DOUBLE_QUOTED_STRING> ) >|	< SINGLE_QUOTED_STRING	: <SINGLE_QUOTE> (~["\""])* <SINGLE_QUOTE> >|	< DOUBLE_QUOTED_STRING	: <DOUBLE_QUOTE> (~["\""])* <DOUBLE_QUOTE> >| 	< #DOUBLE_QUOTE	: "\"" >| 	< #SINGLE_QUOTE	: "\'" >}TOKEN : /* BOOLEAN OPERATORS */{	< AND	: "AND" >| 	< OR	: "OR" >| 	< NOT	: "NOT" >}TOKEN : /* BINARY OPERATORS */{  	< EQUALS				: "=" >| 	< NOT_EQUALS			: "<>" >| 	< GREATER_THAN			: ">" >| 	< LESS_THAN				: "<" >| 	< GREATER_THAN_OR_EQUAL	: ">=" >| 	< LESS_THAN_OR_EQUAL	: "<=" >}TOKEN : /* WHERE OPERATORS */{ 	< BETWEEN				: "BETWEEN" >| 	< LIKE					: "LIKE" >| 	< IN					: "IN" >}TOKEN : /* LIMIT */{	< LIMIT	: "LIMIT" >}TOKEN : /* IDENTIFIER */{ 	< IDENTIFIER			: <IDENTIFIER_SEGMENT> (<PERIOD> <IDENTIFIER_SEGMENT>)* >|  	< IDENTIFIER_SEGMENT	: <IDENTIFIER_START> (<IDENTIFIER_PART>)* >|	< IDENTIFIER_START		: (<UNDERSCORE> | <LETTER>) >
|	< IDENTIFIER_PART		: (<UNDERSCORE> | <LETTER> | <DIGIT>) >
|	< #LETTER				: ["A"-"Z","a"-"z"] >
}SQLParserResult statement() :{	Matchmaker m = null;	Integer l = null;}{(  	( m=or_expr() )? ( l=limit() )? <EOF>)	{ return new SQLParserResult(m, l); }}Matchmaker or_expr() :{	List<Matchmaker> mm = new ArrayList<Matchmaker>();	Matchmaker m;}{	m=and_expr() { mm.add(m); } (LOOKAHEAD(<OR> and_expr()) <OR> m=and_expr() { mm.add(m); } )*		{		if(mm.size() == 1) return mm.get(0);		Matchmaker[] mmArray = mm.toArray(new Matchmaker[mm.size()]);		return Matchmakers.or(mmArray);	}}Matchmaker and_expr() :{	List<Matchmaker> mm = new ArrayList<Matchmaker>();	Matchmaker m;}{	m=parens_expr() { mm.add(m); } (LOOKAHEAD(<AND> and_expr()) <AND> m=parens_expr() { mm.add(m); } )*		{		if(mm.size() == 1) return mm.get(0);		Matchmaker[] mmArray = mm.toArray(new Matchmaker[mm.size()]);		return Matchmakers.and(mmArray);	}}Matchmaker parens_expr() :{	Matchmaker m;	Boolean not = false;}{(	(<NOT> { not = true; } )?		(		m=condition()	|	<OPEN_PARENS> m=or_expr() <CLOSE_PARENS>	))	{		if(not) return Matchmakers.not(m);				return m;	}}Comparable<?> literal() :{	Token t;}{	t=<INTEGER>	{ return Integer.valueOf(t.image); }|	t=<LONG> 	{ return Long.valueOf(stripSuffix(t.image)); }|	t=<FLOAT> 	{ return Float.valueOf(stripSuffix(t.image)); }|	t=<DOUBLE> 	{ return Double.valueOf(stripSuffix(t.image)); }|	t=<STRING>	{ return unquoteString(t.image); }}Matchmaker condition() :{	Matchmaker m;}{(	LOOKAHEAD(2)	m=regular_condition()| 	LOOKAHEAD(2)	m=between_condition()| 	LOOKAHEAD(2)	m=in_condition()| 	LOOKAHEAD(2) 	m=like_condition()		)	{ 		return m; 	}}Matchmaker regular_condition() :{    Token id;	Token valueId;	ComparableProperty prop;	ConditionType type;	Comparable<?> literal = null;	ComparableProperty valueIdProp = null;}{    id=<IDENTIFIER>	{ prop = ComparableProperty.forName(toPath(id.image)); }        (        <EQUALS>					{ type = ConditionType.EQUALS; }    |   <NOT_EQUALS>				{ type = ConditionType.NOT_EQUALS; }    |   <GREATER_THAN>				{ type = ConditionType.GREATER_THAN; }    |   <LESS_THAN>					{ type = ConditionType.LESS_THAN; }    |   <GREATER_THAN_OR_EQUAL>		{ type = ConditionType.GREATER_THAN_OR_EQUAL; }    |   <LESS_THAN_OR_EQUAL>		{ type = ConditionType.LESS_THAN_OR_EQUAL; }	)	(	    literal=literal()	|   valueId=<IDENTIFIER>	{ valueIdProp = ComparableProperty.forName(toPath(valueId.image));}	)	{		switch(type) {					case EQUALS:				if(valueIdProp == null)					return prop.equalTo(literal);				else					return prop.equalTo(valueIdProp);						case NOT_EQUALS:				if(valueIdProp == null)					return prop.notEqualTo(literal);				else					return prop.notEqualTo(valueIdProp);						case GREATER_THAN:				if(valueIdProp == null)					return prop.greaterThan(literal);				else					return prop.greaterThan(valueIdProp);						case LESS_THAN:				if(valueIdProp == null)					return prop.lessThan(literal);				else					return prop.lessThan(valueIdProp);						case GREATER_THAN_OR_EQUAL:				if(valueIdProp == null)					return prop.greaterThanOrEqualTo(literal);				else					return prop.greaterThanOrEqualTo(valueIdProp);						case LESS_THAN_OR_EQUAL:				if(valueIdProp == null)					return prop.lessThanOrEqualTo(literal);				else					return prop.lessThanOrEqualTo(valueIdProp);							}	}}Matchmaker between_condition() :{	ComparableProperty prop;    Token id;    Comparable<?> lower = null;    Comparable<?> upper = null;}{		id=<IDENTIFIER>		<BETWEEN>		lower=literal()		<AND>		upper=literal()		{		prop = ComparableProperty.forName(toPath(id.image));		return prop.between(lower, upper);	}}Matchmaker like_condition() :{	ComparableProperty prop;    Token id;    Token p;}{		id=<IDENTIFIER>		<LIKE>		p=<STRING>		{		prop = ComparableProperty.forName(toPath(id.image));		String pattern = likeToRegexPattern(unquoteString(p.image));		return prop.matches(pattern);	}}Matchmaker in_condition() :{	List<Object> values = new ArrayList<Object>();	ComparableProperty prop;    Token id;    Comparable<?> val;}{		id=<IDENTIFIER>		<IN>		<OPEN_PARENS>		val=literal() { values.add(val); }		(<COMMA> val=literal() { values.add(val); })*		<CLOSE_PARENS>		{		prop = ComparableProperty.forName(toPath(id.image));		Object[] valuesArray = values.toArray(new Object[values.size()]);		return prop.elementOf(valuesArray);	}}Integer limit() :{	Token t;}{	<LIMIT> t=<INTEGER>	{ return Integer.valueOf(t.image); }}